1. 延展的基本使用:(Extension)
    1. 是一个特殊的分类，所以延展也是类的一部分
    2. 特殊之处:
        1. 延展这个分类没有名字
        2. 只有声明没有实现，和本类共享一个实现
    3. 延展的语法:
        ```
        @interface 本类名 ()
        @end
        ```
        只有一个声明，没有实现，和本类共享实现
    4. 添加步骤: 
        ```
        filename 文件名
        new file->objective-c file -> filetype : Extension
        class 本类名
        ```
    5. 基本使用:
        1. 本质是一个分类，作为本类的一部分，只不过是一个特殊的分类，没有名字
        2. 只有声明，没有单独的实现，实现和本类在一起
    6. 和普通的分类的不同
        1. 分类有名字，延展没有
        2. 每一个分类都有单独的声明和实现，延展没有单独的实现，和本类共享实现
        3. 分类只能新增方法，而延展方法成员都可以写
        4. 分类中写@property只会生成setter,getter声明，延展中写@property会自动生成私有属性，也会生成setter和getter的实现。
    7. 延展的使用场景
        1. 要为类写一个真私有的@property，即生成的getter，setter方法只能在类的内部访问，不能在外部访问。即setter，getter只有实现，没有声明，可以用延展来解决。将延展写在本类的实现文件中，这时，写在延展中的成员，相当于这个类的私有成员，其他地方完全无法调用。
        2. 要为类定义私有成员的时候，就用延展，(属性方法之类的)。不要写在implemetation中。不规范，声明在延展中，实现在本类的实现中
        3. 延展天生就是用来私有化成员的。
2. block是一个数据类型。
    1. block是一个数据类型，可以声明一个block变量
    2. block变量专门存储一段代码，可以有参数，可以有返回值
    3. block的声明:
        1. 虽然block变量是用来存储代码的，但是一个block变量中并不是任意的一段代码都可以存的，有限定的，声明的时候，必须指定是否有参数，是否有返回值。
        2. 语法:
            ```
            返回值类型 (^block变量名称) (参数列表);
            void (^myBlock1) (); //声明了一个叫myBlock1的block变量，返回值为void，没有参数
            ```
    4. 初始化block变量
        1. 原理: 写一段符合要求的代码段，存进去就行了
        2. 语法:
            ```
            myBlock1 = ^void (){
                ....;
            };
            ```或者是
            ```
            ^返回值类型 (参数列表){
                ...;
            };
            ```在声明的时候初始化也行
    5. block变量的使用: `block变量名();`
    6. block的简写
        1. 如果我们写的代码的代码段无返回值，**代码段**的void可以省略，声明的不能省
            ```
            void (^myBlock) () = ^(){
                ...;
            };
            ```
        2. 如果我们写的代码段无参数，**代码段**的小括号可以省略，声明的不能省
            ```
            void (^myBlock) () = ^{
                ...;
            };
            ```
        3. 声明block变量时，如果有指定参数，可以只写参数类型，不写参数名
            ```
            void (^myBlock)(int, int) = ^int(int num1, int num2){
                ...;
            };
            ```
        4. 无论代码段是否有返回值，在写代码段时，可以不写返回值类型。
        5. 建议按标准来写，提高可读性。
    7. 简化block变量的复杂定义
        1. typedef 返回值类型 (^新类型名)(参数列表));
    8. block访问外部变量的问题
        1. 在代码块的内部，可以访问外部的局部和全局变量
        2. 在代码块的内部，可以修改全局变量的值，不能修改定义在代码块的外部的局部变量的值
        3. 希望定义的局部变量可以在代码块的内部修改，这样写`__block 变量类型 变量名;`
    9. block作为函数的参数
        1. 无参无返回值的block
            ```
            void test(void (^block1)()){
                ...
                block1();
                ...
            };
            ```
        2. 或者简写
            ```
            typedef void (^NewType)();
            void test (NewType block1){

            };
            ```
        3. 可以将调用者的代码传入函数的内部执行
        4. block作为函数的参数，是在函数部功能的实现不能确定的情况下，调用者传入自己想实现的功能
    10. block作为函数返回值，必须用typedef把其定义为短类型
    11. block与函数
        1. 相同: 都是封装的一段代码
        2. 不同: block是一个数据类型，可以作为函数的参数.
3. 协议 Protocol
    1. 作用: 
        1. 专门用来声明方法，(不声明属性，也不实现方法，只能写方法的声明)
        2. 只要某个类遵守了这个协议，就相当于拥有了这个协议的所有的方法声明，而不用自己定义
    2. 声明:
        ```
        @protocol 协议名 <NSObject>
        @end
        ```
    3. 协议只有一个.h文件
    4. 使用协议:
        ```
        // Dog 遵守了MyProtocol这个协议，Dog拥有MyProtocol所有的方法声明，使用想用的方法时，必须实现该方法
        @interface Dog: NSObject <MyProtocol> 
        @end
        ```
    5. 类是单继承，但是协议可以多遵守
        ```
        @interface Dog: NSObject <MyProtocol1, MyProtocol2>
        @end
        ```
    6. Protocol中的@required 和 @optional
        1. @required修饰的方法的声明，在遵守协议的类中如果没有被实现，就会警告，但是可以编译运行，默认的
        2. @optional修饰的方法的声明，在遵守协议的类中如果没有被实现，不会警告，也不会影响编译运行。
    7. 协议可以继承，而且可以多继承
        ```
        @protocol 协议名 <父协议1, 父协议2>
        @end
        ```
    8. 类名和协议名可以相同
    9. NSObject，所有的oc类的基类，所有协议的基协议
    10. 规范，所有的协议都必须直接或者间接的从基协议继承
    11. 协议的类型限制。
        1. 声明一个指针，可以指向任意对象，但是要求指向的对象遵守指定的协议，不遵守至少有警告(代理设计模式)
            ```
            NSObject<协议名> *obj;
            id<协议名> id1; 常用
            ```
        2. 多个协议
            ```
            NSObject<协议名1, 协议名2> *obj;
            id<协议名1, 协议名2> id1; 常用
            ```
        3. id,NSObject可以是其他的类名，比如自己定义的Person，Student之类的。
    12. 要求某个类遵守某个协议
        ```
        #import <SonProtocol.h>
        @interface Person: NSobject
        @property (nonatomic, strong) id<SonProtocol> son;
        @end
        ```