1. 内存管理概述
    1. 如何将数据存入内存
    2. 数据不在使用的时候，占用的内存空间如何释放。
2. 内存中的五大区域: 栈，堆，数据段，代码段，BSS段
    1. 栈中的局部变量，在代码块执行完毕后回收(局部变量作用域)
    2. BSS段: 未初始化的全局变量和静态变量，初始化后释放，转入数据段
    3. 数据段: 初始化的全局变量和静态变量，程序结束后回收
    4. 代码段: 代码，程序结束后回收
    5. 前面四个自动回收，不用干预
    6. 堆: OC对象，C中用函数申请的空间
3. 堆中的OC对象，是要被回收的，但是不会自动回收，要程序结束的时候才回收，iphone内存机制，40M警告，45M警告，120M闪退
4. 对象无人使用的时候才能回收
5. 引用计数器
    1. 每个对象都有一个属性，叫retainCount，引用计数器，unsigned long 8个字节。用来记录这个对象，当前有多少人使用，默认创建一个对象出来，值就是1，因为类指针变量指向对象。
    2. 当多1个人使用这个对象的时候，要让这个对象的引用计数加一
    3. 当少一个人使用这个对象的时候，要让这个对象的引用计数减一
    4. 引用计数器为0的时候，就会被回收
6. 如何操作引用计数器
    1. 为对象发送1条retain消息，引用计数器加1，多一个人使用的时候才发
    2. 为对象发送一条release消息，引用计数器减1，少一个人使用的时候才发
    3. 当计数器归零的时候，就会调用对象的dealloc方法释放
7. 内存管理分类
    1. MRC: Manual Reference Counting。手动引用计数，手动内存管理，程序员手动发送retain，release
    2. ARC: Automatic Reference Counting。自动引用计数，自动内存管理，系统自动发送retain，release，在该模式下retain，release，dealloc这些方法无法使用
8. Xcode7开始默认ARC开发
    1. 如何关闭ARC？
        1. 在target的buildSettings里的Language-Obective里把Auto Reference Counting选为NO
        2. 只要dealloc被执行，该方法就会被回收
            1. 重写dealloc的规范
                ```
                @implemetation Person:
                -(void) dealloc {
                    NSLog(@"对象被回收了");
                    // 调用super的dealloc方法必须在最后一行
                    [super dealloc];
                }
                ```
9. 内存管理的重点
    1. 什么时候为对象发送retian消息
    2. 什么时候为对象发送release消息
10. 内存管理的原则
    1. 有对象的创建就要匹配一个release
    2. retain的次数和release的次数匹配
    3. 谁用谁retain，谁不用谁retain
    4. 只有在多一个人使用的时候才retian，在少一个人使用的时候release
    5. 有始有终，有加就有减
11. 野指针
    1. C中的野指针: 定义一个指针变量，没有初始化，这个变量的值是一个垃圾值，指向随机空间，
    2. OC中的野指针: 指针指向的对象已经被回收了，就叫野指针
12. 对象回收的本质
    1. 内存回收的本质，申请一个变量，实际上就是向系统申请指定字节数的空间，这些空间不会再分配给别人了，当变量回收的时候，代表变量占用的字节空间从此可以分配给别人了。但是字节空间存储的数据还在，这就是垃圾值的由来
    2. 对象的回收，就是对象占用的字节空间可以分配给别人了，但是对象的数据还在
13. 僵尸对象，1个已经被释放的对象，但这个对象的空间还没有分配给别人，这就叫僵尸对象，用野指针去访问僵尸对象，可能出问题，也可能不出
14. 希望访问的是僵尸对象的时候肯定报错，就要把僵尸对象的实时检测打开。不默认打开僵尸对象的检测，是因为这个极其影响性能
15. 如何避免僵尸对象错误，当一个指针变为野指针后，将指针的值设置为nil，这样通过该指针去访问对象的方法，包括点语法时，无反应，不会报错，但是访问属性会报错
16. 内存泄露
    1. 指一个对象没有及时回收，一直驻留在内存中，直到程序结束回收
    2. 单个对象的内存泄露:
        1. 有对象的创建，没有release
        2. retain的次数和release的次数不匹配
        3. 在不适当的时候，为指针赋值为nil
        4. 在方法中为传入的对象不适当的retain
17. MRC中的setter方法的内存管理
    1. 规范
        ```
        -(void) setCar:(Car *) car{
            if (_car != car){
                [_car release];
                _car = [car retian];
            }
        }
        ```
    2. 只针对OC对象，，其他类型的按原来的写
18. `@property` 生成的方法的实现中，都是直接赋值
    1. `@property`的四组参数
        1. 与多线程相关的: atomic, nonatomic。
        2. 与setter实现相关的: assign，retain
        3. 与只读，读写相关的readonly, readwrite
        4. 与生成的setter，getter的方法名称相关的。setter= getter=
    2. 与多线程相关的:
        1. atomic。默认的，会给setter方法添加一个线程锁。线程安全，效率低
        2. nonatomic。非默认的，不会给setter添加线程锁，线程不安全，效率高
        3. 目前单线程，就用nonatomic
    3. 与setter实现相关的
        1. assign 默认的，生成的setter的方法实现是直接赋值。MRC中非OC对象用这个
        2. retain 非默认，生成的setter的方法的实现是标准的MRC内存管理，刚讲的那种，OC对象用这个(MRC模式下)。但是不会在dealloc中release
    4. 与setter，getter的方法名相关的的参数
        1. getter=Age
        2. setter=setage: 注意setter方法的方法名带冒号
        3. setter方法的名字一般来说不会改动
        4. getter方法的名字，遇到BOOL类型的属性时，就修改getter为is开头，提高阅读性
    5. 这几个参数次序随意
19. @class 
    1. 当两个类互相包含时，Person.h包含Book.h，Book.h包含Person.h这个时候，会出现循环引用情况，导致编译失败
    2. 解决方案，其中一个header文件不要用#import去引入对方的头文件，用@class类名，来标注这是一个类，这样就可以在不引入对方请求头的情况下，告诉编译器这是一个类
    3. @class与#import的区别
        1. import 是将指定的文件的内容拷贝到写指令的地方
        2. @class 并不拷贝任何内容，只是告诉编译器这是一个类
    4. 在.m文件中引入另一个类的头文件，解决Xcode对于@class无提示的问题
20. 循环retain
    1. 当两个对象相互引用的时候，都用@property的retain，都互相在setter中retain，造成两个对象互相引用，两个都没办法释放
    2. 可以一个用retain，一个用assign，记得dealloc去掉一个release