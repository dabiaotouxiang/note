# 内存
内存中的五大区域
## 栈区域
存储局部变量
## 堆区域
允许程序员手动申请指定字节数的空间来使用
## BSS段
存储未初始化的全局和静态变量，程序开始的时候，是没有初始化的
## 数据段/常量区
存储已经初始化的全局和静态变量，还有常量数据
## 代码段
存储代码

# 指针
## 指针与字符数组
### 字符数组的两种声明方式
1. `char *name = "jack";` 指针方式
2. `char name[] = "jack";` 数组方式
### 两种方式的区别
#### 都是局部变量的时候
1. 数组方式的数组名和数组的内容都在栈区
2. 指针方式的数组名在栈区，字符串以字符数组地方式存储在数据段/常量区
#### 都是全局变量的时候
1. 数组方式在常量区
2. 指针方式，指针和字符数组都是在常量区

#### 结构上的区别
1. 以字符数组存储: 无论如何是一个字符数组，然后字符串的每一个字符存储在数组的元素之中
2. 以字符指针存储: 现有一个字符指针变量，字符串数据以字符数组的形式存储在常量区

#### 修改时的区别
1. 字符数组。无论是局部的还是全局的，都可以修改
2. 字符指针的形式，都无法修改，无论是局部的还是全局的

### 字符串的恒定性(针对字符指针方式)
1. 将字符指针指向的数据存储到常量区的时候，并不是直接将字符串存储至常量区，而是先检查常量区中是否有相同内容的字符串，有的话返回相同的字符串的地址，没有的话，再存储
2. 重新给字符指针赋值的时候，实际上是再创建一个字符串给指针
3. 如何修改字符指针或者字符串数组名指向的字符串
    1. `char *name = "jack"; name = "rose";`
    2. `char name[] = "jack"; 遍历数组进行替换`

### 字符串声明的两种方式的优劣
建议用字符指针存储字符串，因为字符数组的长度固定，字符指针长度不定，随便赋值

## 字符串数组
### 字符数组格式
1. `char name[][10] = {"jack", "rose"};` 每一行的长度固定
2. `char *name[4] = {"jack", "rose"};` 每一行的长度不固定

### 字符串数组的排序
遍历，按a-z比较用strcmp, 按长度比较用strlen

# file函数
## fputs
将字符串数据输出至指定的流
1. 标准输出流 --> 控制台
2. 文件流 --> 磁盘上文件
### fputs格式
fputs(输出字符串, 指定流)
1. 输出至控制台 fputs(name, stdout);
2. 输出至文件
    ```
    // 操作文件模式: 1. "w" 写，有该文件就替换，没有该文件就创建 2. "a" 追加
    FILE* pFile = fopen("文件路径", 操作文件模式);
    fputs(name, pFile);
    // close 不能忘
    fclose(pFile);
    ```
## fgets
从指定的流读取字符串
1. 标准输入流 --> 控制台
2. 文件流 --> 磁盘上文件
### fgets格式
1. 控制台
```
char input[10];
fgets(input, 10, stdin);
// 最多接受9个字符，还有一个"\0"。多余的不接受
// 如果小于n - 1，回车也会被接收，需要在后面判断是否是"\n"结尾，是的话换回"\0"
```
类型|scanf|gets|fgets
--|--|--|--
认为空格结束|是|否|否
超过数组长度崩溃|是|是|否
2. 文件流
```
// 操作文件模式: 1. "r" 读取
FILE* pFile = fopen("文件路径", 操作文件模式);
fgets(content, 50,` pFile);
// close 不能忘
fclose(pFile);
```

# const关键字
## const修饰变量
`const int num = 10;` 只能读取，不能修改 和`int const num = 10;` 等同
## 修饰数组
`const int arr[4] = {10, 20, 30, 40};` 数组的元素的值不能修改 和`int const arr[4] = {10, 20, 30, 40};`等同
## 修饰指针
1. 
```
int num = 10;
const int *p1 = &num;
```
无法通过指针去修改num的值，但是可以num=100直接改，也可以`int age = 10; p1 = &age;`即p1的指向也可以改
2. 
```
int const *p1 = &num;
```
和第一个一样
3. 
```
int * const p1 = &num;
```
p1的指向不能改，但是可以通过p1去修改num的值
4. 
```
int const * const p1 = &num;
```
指向不能改，也不能通过p1去修改num的值

## 使用场景
1. 某些数据是固定的，不允许修改的时候
2. 当函数的参数是指针变量的时候，函数的内部可能会改变实参的值，就用const修饰形参

# 在堆中申请空间
1. 在堆中申请空间，不主动释放是不会释放的，除非程序结束
2. 步骤: 1. 申请 2. 使用 3. 释放
3. 函数 malloc calloc realloc 都在stdlib.h中
## malloc
### 作用
向堆申请指定字节的空间
### 格式
malloc(size_t); 
### 返回值
`void * malloc(size_t);` `void *`指无类型的指针。指针指向申请的空间的第一个地址

### 如何接收返回值
1. 一个一个字节的接收 char
2. 四个四个的接收 int float
3. 八个八个的接收 double

### 内存分配
堆区申请的空间从低到高分配，不一定连续，每次申请的字节空间都是从`0x.....0`开始。每次申请的几个字节之间连续。

### 初始化
申请的字节没有初始化的时候有垃圾值

### 失败的情况
空间不够的时候申请失败，会返回NULL

### 释放
用完后一定要释放`free(指针);`。没有free的话，会在程序结束后释放

## calloc
### 格式
int *p1 = calloc(3, sizeof(int)); // 申请3个int的空间
### 优点
可以自动清零，其他的和malloc差不多

## realloc
### 作用
用于扩容，用malloc和calloc申请的空间不够时，就用realloc进行扩容
### 格式
```
realloc(指针, 扩容后大小);
```
### 内存中的分配
1. 原来分配的空间后面有足够的空间时，直接在原来的空间后面扩容
2. 原来分配的空间后面没有足够的空间时，就再找一块空间，重新弄，还会将原来的数据拷贝过来。原来的空间也会释放(可以用来放数组)。