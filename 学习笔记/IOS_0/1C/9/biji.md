# 格式控制符/占位符
即printf中的%d等，作用: 不同类型的变量在内存中存储的形式不同，所以读取的格式也不同，为了保证正确的读取，需要用正确的占位符

# 垃圾值
变量的回收是回收内存的地址，地址中的值不会被清零。当这个地址给了另一个没有在声明的时候初始化的变量的时候，就成了垃圾值

全局变量自动初始化为0

# 数组
作用: 存储多个数据
## 特点
1. 可以存储多个数
2. 1个数组中只能存储类型相同的多个数据，类型在创建的时候指定
3. 存储的个数固定，在创建的时候指定
4. 方便管理

## 声明
类型 数组名\[个数\];

## 术语
1. 元素
2. 索引/下标
3. 长度

## 数组的元素
1. 元素就是一个普通的变量，为元素赋值，就是为一个普通的变量赋值
2. 为元素赋值的时候，赋值的数据的类型要和元素的类型一致。不一致的时候自动转换
3. 下标不能越界
4. 取元素的地址`&arr[n]`

## 数组的长度
1. 声明数组必须指定长度
2. 长度可以是常量或者变量，表达式，字符等
3. 不能是小数
4. 可以是1或者0
5. 不能是负数
6. 可以是宏

## 元素的默认值和初始化
没有赋值的时候，元素中的值是垃圾值
### 初始化
1. 声明的时候初始化 `int arr[3]={1,2,3}`。使用这种方式的时候，数组的长度不能用变量，因为编译的时候，这个赋值会被转换为一个一个赋值的方式，这种时候变量在编译的时候并不能获取变量的值。但是宏可以，因为宏在编译前就知道值了
2. `int arr[] = {....};`可以省略长度
3. `int arr[3]={3}` 其他位置默认为0
4. 指定下标  `int arr[3] = {[0]=1, [2]=2}` 其他的默认初始化为0

## 数组在内存中的存储形式
`int arr[3];`
1. 声明一个数组，从内存中高字节的地方向低字节的地方申请。申请的字节数为`数组长度*元素字节`
2. 低索引元素在低地址，高索引元素在高地址
3. 元素的低字节在地址，高字节在高地址
4. 元素的地址就是最低字节的地址

## 数组的地址
1. 数组名这个变量存储的是数组的地址
2. 数组名 == 数组地址 == 第0个元素的地址

## 数组的长度的计算
1. sizeof(数组名); 可以得到数组的总长度
2. sizeof(数组名)/sizeof(int or float) 得到数组的元素的个数
3. 为了避免不同的系统编译器中类型的长度不一样的影响，一般这么写来算元素的个数`sizeof(arr)/sizeof(arr[0])`

## 数组的用处
遇到多个同类型同意义的变量的时候

## 函数的数组参数
```
void test(int num[], int len);
```
在函数内部去计算num的长度，无论怎么算，长度都是8个字节，因为函数中接收数组的时候，接收的是8个字节的长度的数组的地址(指针变量)，所以需要把数组的元素个数也传递过来。

数组传递到函数中的与作为实参变量的是同一个，在函数中修改，函数外也会被修改

## 数组的排序
1. 选择排序
```
int num[] = {1,2,3,4,5};
int len = sizeof(num)/sizeof(num[0]);
for (i = 0; i < len - 1; i++)
{
    for (j = i + 1; j < len; j++)
    {
        if (num[i] < num[j])
        {
            int tmp = num[i];
            num[i] = num[j];
            num[j] = tmp;
        }
    }
}
```
2. 冒泡排序
```
int num[] = {1,2,3,4,5};
int len = sizeof(num)/sizeof(num[0]);
for (i = 0; i < len - 1; i++)
{
    for (j = 0; j < len - 1 - i; j++)
    {
        if (num[j] < num[j + 1])
        {
            int tmp = num[j];
            num[j + 1] = num[j];
            num[j] = tmp;
        }
    }
}
```

## 二分法查找
```
val = 4
int num[] = {1,3,5,7,9};
int low = 0;
int len = sizeof(num)/sizeof(num[0]);
int high = len -1;
while (low < high){
    int index = (high + low) / 2;
    if (num[index] < key)
    {
        low = index + 1;
    }
    else if (num[index] > key)
    {
        high = index - 1;
    }
    else
    {
        printf("index:%d", index);
        break;
    }
}
```