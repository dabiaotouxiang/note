# 函数的本质
## 汇编指令
1. BL指令 通过改PC寄存器改变CPU的执行方向
2. mov 把内存中的值移入寄存器，但是mov不能设置PC
3. ARM提供了bl指令来改PC的值，bl被称为转移指令
## 栈
一种有特殊访问模式的存储空间(先进后出)
### 操作栈的指令
ARM64开始取消了32位的LDM，STM，PUSH，POP指令，取而代之的是ldr/ldp，str/stp，ARM64对栈的**操作是16字节对齐的**

ARM64的拉伸必须是16字节对齐，sub和add的操作必须是16字节的倍数，ldr，str之类的不需要对齐

str将数据从寄存器写入内存(store register) stp 操作两个寄存器  stur 操作w32位的寄存器
ldr将数据从内存写入寄存器(load register)  ldp 操作两个寄存器

## 栈的地址
不同的函数的栈的内存地址从高向低分配(栈低)

栈中的数据从低向高写

写入栈的代码
```
stp x0, x1, [sp, #0x10] // 在sp+#0x10的位置，从低到高写入内存
ldp x0, x1, [sp, #0x10] // 在sp+#0x10的位置，从低到高读取数据
```

## SP和FP寄存器
SP寄存器在任意时刻保存栈底的地址

FP寄存器也称为x29，在某些时刻用来保存栈顶的地址(有时保存)

## bl 指令
1. 将bl下一条指令放入lr(x30)
2. 跳转到bl后面的地址
## ret
默认使用lr存储的值，通过底层命令提示CPU此处作为下条地址(ARM64的特点，面向硬件做的优化)

## lr(x30)
函数的返回地址，ret执行的时候，会寻找x30保存的地址值，存入PC，指导CPU去返回

## 函数的嵌套
对于函数套函数的情况，要注意在bl之前，把lr(x30)的值入栈
```
stp x29, x30, [sp, #-0x10] // 简写
/*
上面相当于 sub sp, sp, 0x10 //先拉伸
         stp x29, x30, [sp] // 将数据存入
*/
mv x29, sp
bl ...
ldp x29, x30, [sp], 0x10 // 简写
/*
ldp x29, x30, [sp] // 将数据读出
add sp, sp, #0x10 // 将栈移回原位
*/
```

## 函数的参数和返回值
将外围的函数的参数放入栈，然后把内部函数的参数放入x1,x0,结果放入w0,w0就是返回值

ARM64下，函数的参数放在x0-x7这八个寄存器，超过8个参数，就入栈，返回值放入x0寄存器

### 死递归和死循环
死递归 x29和x30不断入栈，会爆栈

死循环一般不会

### 内存溢出
堆从低到高分配，栈从高到低分配，两个相撞就会溢出

# lldb
memory read 地址 读取内存中的数据

memory write 地址 数据 将数据写入内存

# xcode写汇编
1. AssemblyFile 汇编文件 .s 结尾 相当于源文件
```
.text 代表下面的是代码
.global _A, _B 代表全局 外部可调用    
_A: 
    mov x0, #0xa0
    mov x1, #0x00
    add x1, x0, #0x14
    mov x0, x1
    bl _B
    mov x0, #0x0
    ret
_B:
    add x0, x0, #0x10
    ret
```
调用
```
int A(); // 先声明
int main()
{
    a();
}
```