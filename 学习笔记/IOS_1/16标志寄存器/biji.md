# 状态寄存器
CPSR(32位的) 按位起作用

其中低八位的被称为控制位。程序无法修改，不用记

8-27位的保留，不用记

28-31位的 条件码标志位，可以被算术或者逻辑运算的结果改变，并决定某条指令是否被执行

并不是所有的指令都会影响cpsr的执行，逻辑运算符会，add不会，adds会，subs也会。

## b.ne 
带条件的b跳转。看cpsr决定，cpsr只看29-31位

## 四个标志位
1. 31 N
2. 30 Z
3. 29 C
4. 28 V


## 如何书写内联汇编

```
void func(){
    asm(
        "mov w0, #0xffffffff\n"
        "adds w0, w0, #0x0\n"
    )
}
```

## N标志(negative)
记录指令执行后，结果是否为负。负的话N=1，非负为0

其实就是保存结果的最高位


## Z标志(zero)
Z记录结果是否为0，如果结果为0，z记录为1，代表结果是0，如果结果不为0，z记录0，代表结果不为0

## C标志(Carry)
进位标志位，一般进行无符号数运算

加法: 结果产生进位(无符号数溢出) C=1 否则 C=0
减法(包含CMP): 结果产生借位(无符号数溢出) C=0 否则 C=1

相当于无符号数前面的那一位。进位了，前面那一位是1，没进位，前面那一位是0.借位了，前面那一位的数字就是0了，没借位，前面那一位就是1.反映的是前面那一位的数值

## V标志 (OverFlow)
溢出标志 有符号数运算时，超过了机器标识的范围，溢出只看符号位变没变

```
正 + 正 = 负 溢出
负 + 负 = 正 溢出
正 + 负 不可能溢出
```

# 全局变量和常量

一般都会是下面的格式
```
adrp x0, 1; 代表 将当前命令的地址的后十二位二进制位归零，然后加上1左移十二个二进制位得到的地址值(该地址值一般为内存分页，当前页的起始值)，赋值给x0
add x0, x0, #0xf28; 给x0的地址值加上偏移量，得到的就是全局变量或者常量的地址值
```